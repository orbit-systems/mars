#ifndef MARS_LEX_H
#define MARS_LEX_H

#include "compiler.h"
#include "reporting.h"

typedef enum TokenKind : u8 {
    TOK_INVALID,

    TOK_EOF,
    TOK_NEWLINE,

    TOK_OPEN_PAREN,    // (
    TOK_CLOSE_PAREN,   // )
    TOK_OPEN_BRACE,    // {
    TOK_CLOSE_BRACE,   // }
    TOK_OPEN_BRACKET,  // [
    TOK_CLOSE_BRACKET, // ]

    TOK_HASH,        // #
    TOK_COLON,       // :
    TOK_COLON_COLON, // ::
    TOK_COMMA,       // ,
    TOK_DOT,         // .
    TOK_CARET,       // ^
    TOK_EXCLAM,      // !
    TOK_QUESTION,    // ?

    TOK_EQ,         // =
    TOK_PLUS_EQ,    // +=
    TOK_MINUS_EQ,   // -=
    TOK_MUL_EQ,     // *=
    TOK_DIV_EQ,     // /=
    TOK_REM_EQ,     // %=
    TOK_AND_EQ,     // &=
    TOK_OR_EQ,      // |=
    TOK_LSHIFT_EQ,  // <<=
    TOK_RSHIFT_EQ,  // >>=
    TOK_TIDLE_EQ,   // ~=

    TOK_PLUS,       // +
    TOK_MINUS,      // -
    TOK_MUL,        // *
    TOK_DIV,        // /
    TOK_REM,        // %
    TOK_AND,        // &
    TOK_OR,         // |
    TOK_LSHIFT,     // <<
    TOK_RSHIFT,     // >>
    TOK_TILDE,      // ~

    TOK_EQ_EQ,      // ==
    TOK_NOT_EQ,     // !=
    TOK_LESS_EQ,    // <=
    TOK_GREATER_EQ, // >=
    TOK_LESS,       // <
    TOK_GREATER,    // >

    TOK_RARROW,     // ->
    TOK_LARROW,     // <-
    TOK_ARROW,      // <->

    TOK_RANGE,      // ..
    TOK_RANGE_EQ,   // ..=

    TOK_IDENT,
    TOK_INT_LITERAL,
    TOK_FLOAT_LITERAL,
    TOK_CHAR_LITERAL,
    TOK_STRING_LITERAL,

    TOK_IINT_TYPE,
    TOK_UINT_TYPE,
    TOK_FLOAT_TYPE,

    TOK_K_UNDERSCORE,

    TOK_K_SIZEOF,
    TOK_K_BITSIZEOF,
    TOK_K_ALIGNOF,
    TOK_K_OFFSETOF,

    TOK_K_PUB,

    TOK_K_DEF,
    TOK_K_LET,
    TOK_K_VAR,

    TOK_K_IF,
    TOK_K_THEN,
    TOK_K_ELSE,
    TOK_K_SWITCH,
    TOK_K_CASE,
    TOK_K_WHILE,
    TOK_K_DEFER,

    TOK_K_UNREACHABLE,
    TOK_K_RETURN,
    TOK_K_BREAK,

    TOK_K_UNDEFINED,
    TOK_K_NULL,
    TOK_K_TRUE,
    TOK_K_FALSE,
    TOK_K_SELF,

    TOK_K_INLINE,
    TOK_K_NOINLINE,
    TOK_K_COMMON,
    TOK_K_SEALED,
    TOK_K_CONST,
    TOK_K_STATIC,
    TOK_K_NOALIAS,
    TOK_K_ALLOWZERO,
    TOK_K_ALIGNAS,
    TOK_K_OFFSETAS,
    TOK_K_PACKED,
    TOK_K_BITPACKED,

    TOK_K_VOID,
    TOK_K_TYPE,
    TOK_K_NORETURN,
    TOK_K_SELF_TYPE,
    TOK_K_ISIZE,
    TOK_K_USIZE,

    TOK_K_STRUCT,
    TOK_K_UNION,
    TOK_K_ENUM,
    TOK_K_INTERFACE,
} TokenKind;

#ifdef HOST_POINTER_48_BITS
    /// A token of text from a file.
    typedef struct Token {
        /// The token's kind. (TokenKind)
        u64 kind : 15;
        /// Whether the token is a 'fake' token generated by the lexer,
        /// e.g. unmatched closing delimiters that the compiler inserted
        /// to help the parser recover from errors.
        u64 fake : 1;
        /// First 48 bits of a pointer to the first character in the text.
        /// \note Owned by the `SourceFile`, which is owned by the `MarsCompiler` object.
        i64 raw : 48;
    } Token;
#else
    /// A token of text from a file.
    typedef struct Token {
        /// The token's kind.
        TokenKind kind;
        /// Whether the token is a 'fake' token generated by the lexer,
        /// e.g. unmatched closing delimiters that the compiler inserted
        /// to help the parser recover from errors.
        bool fake;
        /// First 48 bits of a pointer to the first character in the text.
        /// \note Owned by the `SourceFile`, which is owned by the `MarsCompiler` object.
        char* raw;
    } Token;
#endif

/// Return the pointer to the character a token `t` starts at.
static inline const char* token_start(Token t) {
    return (const char*)(isize)t.raw;
}

/// A lexer for making tokens from text.
typedef struct Lexer {
    /// Current byte the lexer is processing.
    usize cursor;

    /// Reference to `current_file`s source text.
    /// \note Owned by the `SourceFile`, which is owned by the `MarsCompiler` object.
    string source;

    /// ID of current file the lexer is operating on.
    SourceFileId current_file;

    /// List of tokens generated from the source text.
    Vec(Token) tokens;

    /// List of currently-unclosed bracketing tokens. 
    /// ( [ {
    Vec(Token) unclosed_delimiters;


    MarsCompiler* marsc;

} Lexer;

/// Create a lexer on source file `file` attached to compiler instance `marsc`.
Lexer lexer_new(MarsCompiler* marsc, SourceFileId file);

/// Destroy lexer `l` and return its token list.
Vec(Token) lexer_destroy_to_tokens(Lexer* l);

/// Scan lexer `l`'s source text for the next token.
/// \return Whether a new token can be generated from a subsequent call.
bool lexer_next_token(Lexer* l);

#endif // MARS_LEX_H

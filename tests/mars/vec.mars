pub struct Vec(T: type, A: ^static std::Allocator) {
    data: [^]T,
    len, cap: usize,

    pub fun new(capacity: usize): self {
        let cap = builtin:max(capacity, 2);
        let len = 0;
        let data = A.alloc(sizeof T * capacity) orelse unreachable;

        .{data, len, cap}
    }

    // ensure capacity is at least "min"
    fun ensure_capacity(^self, min: usize) {
        if self.cap < min {
            self.cap = min + min >> 1;
            self.data = A.realloc(self.data, sizeof T * capacity);
        }
    }

    pub fun append(^self, item: T) {
        self.ensure_capacity(self.len + 1);
        self.data[self.len] = item;
        self.len += 1;
    }

    pub fun append_many(^self, items: []const T) {
        self.ensure_capacity(self.len + items.len);
        builtin::copy(&self.data[self.len], items.data, items.len);
        self.len += items.len;
    }

    pub fun prepend(^self, item: T) {
        self.ensure_capacity(self.len + 1);
        builtin::move(&self.data[1], self.data, self.len);
        self.data[0] = item;
        self.len += 1;
    }
    
    pub fun prepend_many(^self, items: []const T) {
        self.ensure_capacity(self.len + 1);
        builtin::move(&self.data[items.len], self.data, self.len);
        builtin::copy(self.data, items.data, items.len);
        self.len += items.len;
    }

    pub fun insert(^self, index: usize, item: T) {
        if index == 0 {
            self.prepend(item);
            return;
        }
        if index == items.len {
            self.append(item);
            return;
        }
        self.ensure_capacity(self.len + 1);
        builtin::move(&self.data[index + 1], &self.data[index], self.len - index);
        self.data[index] = item;
        self.len += 1;
    }

    pub fun insert_many(^self, index: usize, items: []const T) {
        if index == 0 {
            self.prepend_many(items);
            return;
        }
        if index == items.len {
            self.append_many(items);
            return;
        }
        self.ensure_capacity(self.len + items.len);
        builtin::move(&self.data[index + items.len], &self.data[index], self.len - index);
        builtin::copy(&self.data[index], items.data, items.len);
        self.len += items.len;
    }

    impl builtin::ops::Index(usize) {
        pub def Result = T;
        pub fun op(self, i: usize): ^Result {
            &self.data[i]
        }
    }
}

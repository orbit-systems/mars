// takes a comptime-known static reference to an allocator.
pub struct Vec[A: std::Allocator](E: type, S: builtin::types::Integer, allocator: ^static A) {
    data: [^]E,
    len, cap: S,

    pub fun new(capacity: S): self {
        var vec: self = undefined;
        vec.init(capacity);
        vec
    }

    pub fun init(^self, capacity: S) {
        self.cap = builtin:max(capacity, 2);
        self.len = 0;
        self.data = allocator.alloc([^]E, cap).?;
    }

    pub fun deinit(^self) {
        self.cap = 0;
        self.len = 0;
        allocator.free(self.data);
    }

    pub fn reserve(^self, additional: S) {
        self.ensure_capacity(self.len + additional);
    }

    // ensure capacity is at least "min"
    fun ensure_capacity(^self, min: S) {
        if self.cap < min {
            self.cap = min + min >> 1;
            self.data = allocator.realloc(self.data, cap).?;
        }
    }

    pub fun append(^self, item: E) {
        self.ensure_capacity(self.len + 1);
        self.data[self.len] = item;
        self.len += 1;
    }

    pub fun append_many(^self, items: []const E) {
        self.ensure_capacity(self.len + items.len);
        builtin::copy(&self.data[self.len], items.data, items.len);
        self.len += items.len;
    }

    pub fun prepend(^self, item: E) {
        self.ensure_capacity(self.len + 1);
        builtin::copy_back(&self.data[1], self.data, self.len);
        self.data[0] = item;
        self.len += 1;
    }
    
    pub fun prepend_many(^self, items: []const E) {
        self.ensure_capacity(self.len + 1);
        builtin::copy_back(&self.data[items.len], self.data, self.len);
        builtin::copy(self.data, items.data, items.len);
        self.len += items.len;
    }

    pub fun insert(^self, index: S, item: E) {
        if index == 0 {
            self.prepend(item);
            return;
        }
        if index == items.len {
            self.append(item);
            return;
        }
        self.ensure_capacity(self.len + 1);
        builtin::copy_back(&self.data[index + 1], &self.data[index], self.len - index);
        self.data[index] = item;
        self.len += 1;
    }

    pub fun insert_many(^self, index: S, items: []const E) {
        if index == 0 {
            self.prepend_many(items);
            return;
        }
        if index == items.len {
            self.append_many(items);
            return;
        }
        self.ensure_capacity(self.len + items.len);
        builtin::copy_back(&self.data[index + items.len], &self.data[index], self.len - index);
        builtin::copy(&self.data[index], items.data, items.len);
        self.len += items.len;
    }

    pub fun remove_ordered(^self, index: S) {
        if index == items.len - 1 {
            self.len -= 1;
            return;
        }

        builtin::copy_front(&self.data[index], &self.data[index + 1], self.len - 1 - index);
        self.len -= 1;
    }

    pub fun remove_unordered(^self, index: S) {
        if index == items.len - 1 {
            self.len -= 1;
            return;
        }

        self.data[index] = self.data[self.len - 1];
        self.len -= 1;
    }

    impl builtin::ops::Index(usize) {
        pub def Result = E;
        pub fun op(self, i: usize): ^Result {
            &self.data[i]
        }
    }
}

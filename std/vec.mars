def AllocErr = std::Allocator::Err;

pub struct Vec[A: std::Allocator](E: type, allocator: ^static A) {
    data: [^]E,
    len, cap: usize,

    pub fun new(capacity: usize): AllocErr?Self {
        var vec: Self = undefined;
        vec.init(capacity).?;
        vec
    }

    pub fun init(^self, capacity: usize): AllocErr?void {
        self.cap = builtin::max(capacity, 2);
        self.len = 0;
        self.data = allocator.alloc([^]E, cap).?;
    }

    pub fun destroy(^self) {
        self.cap = 0;
        self.len = 0;
        allocator.free(self.data);
    }

    pub fn reserve(^self, additional: usize): AllocErr?void {
        self.ensure_capacity(self.len + additional);
    }

    // ensure capacity is at least "min"
    fun ensure_capacity(^self, min: usize): AllocErr?void {
        if self.cap < min {
            self.cap = min + min >> 1;
            self.data = allocator.realloc(self.data, cap).?;
        }
    }

    pub fun append(^self, item: E): AllocErr?void {
        self.ensure_capacity(self.len + 1).?;
        self.data[self.len] = item;
        self.len += 1;
    }

    pub fun append_many(^self, items: []const E): AllocErr?void {
        self.ensure_capacity(self.len + items.len).?;
        builtin::copy_front(&self.data[self.len], items.data, items.len);
        self.len += items.len;
    }

    pub fun prepend(^self, item: E): AllocErr?void {
        self.ensure_capacity(self.len + 1).?;
        builtin::copy_back(&self.data[1], self.data, self.len);
        self.data[0] = item;
        self.len += 1;
    }
    
    pub fun prepend_many(^self, items: []const E): AllocErr?void {
        self.ensure_capacity(self.len + 1).?;
        builtin::copy_back(&self.data[items.len], self.data, self.len);
        builtin::copy_front(self.data, items.data, items.len);
        self.len += items.len;
    }

    pub fun insert(^self, index: usize, item: E): AllocErr?void {
        if index == 0 {
            self.prepend(item);
            return;
        }
        if index == items.len {
            self.append(item);
            return;
        }
        self.ensure_capacity(self.len + 1).?;
        builtin::copy_back(&self.data[index + 1], &self.data[index], self.len - index);
        self.data[index] = item;
        self.len += 1;
    }

    pub fun insert_many(^self, index: usize, items: []const E): AllocErr?void {
        if index == 0 {
            self.prepend_many(items);
            return;
        }
        if index == items.len {
            self.append_many(items);
            return;
        }
        self.ensure_capacity(self.len + items.len).?;
        builtin::copy_back(&self.data[index + items.len], &self.data[index], self.len - index);
        builtin::copy_front(&self.data[index], items.data, items.len);
        self.len += items.len;
    }

    pub fun remove_ordered(^self, index: usize) {
        if index == items.len - 1 {
            self.len -= 1;
            return;
        }

        builtin::copy_front(&self.data[index], &self.data[index + 1], self.len - 1 - index);
        self.len -= 1;
    }

    pub fun remove_unordered(^self, index: usize) {
        if index == items.len - 1 {
            self.len -= 1;
            return;
        }

        self.data[index] = self.data[self.len - 1];
        self.len -= 1;
    }

    impl builtin::ops::Index(usize) {
        pub def Result = E;
        pub fun op(^self, i: usize): ^Result {
            &self.data[i]
        }
    }
}
